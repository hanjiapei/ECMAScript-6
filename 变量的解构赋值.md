# 变量的解构赋值
## 1.数组的解构赋值
### 基本用法
ES6允许按照一定模式，从数组和对象中提取值，从而对变量进行赋值，这被称为解构（Destructuring）。
以前(ES5),为变量赋值，只能直接指定值。
```javascript
let a = 1;
let b = 2;
let c = 3;
```
ES6允许写成下面这样。
```javascript
let [a,b,c] = [1,2,3];
```
上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。
[总结]本质上，这种写法属于“模式匹配”只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。
```javascript
 let [foo,[bar,baz]] = [1,[2,3]];
 foo//1
 bar//2
 baz//3

 let [,,third] = ['foo','bar','baz'];
 third //'baz'

 let [x,,y] = [1,2,3];
 x//1
 y//3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```
如果解构不成功，变量的值等于<code>undefined</code>
```javascript
let foo = [];//foo = undefined
let [bar,foo] = [1];// bar = 1; foo = undefined
```
另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
```javascript
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```
上面两个例子，都属于不完全解构，但是可以成功。
[总结]如果等号两边的变量和数值数量想等的话，那么就会依次赋值，如果等号左边的变量多于等号右边的数值的话，那么等号左边多出来的变量
就会赋值undefined，等号左边的变量少于等号右边的数值的数量的话，那么等号左边的变量等于对应的等号右边的数值

如果等号的右边不是数组（或者严格地说，不是可遍历的结构，那么将会报错。
```javascript
//以下代码全部报错
let [foo] = 1;
let [bar] = false;
let [baz] = NaN;
let [abc] = undefined;
let [sta] = null;
let [fbr] = {};
```
[总结] 上面的语句都会报错，因为等号右边的值，要买转化为对象以后不具备Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。